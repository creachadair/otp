package otpauth

import (
	"bytes"
	"encoding/base64"
	"encoding/binary"
	"errors"
	"fmt"
	"net/url"
	"strings"

	"github.com/creachadair/wirepb"
)

// ParseMigrationURL parses an otpauth-migration URL in the format generated by
// the Google Authenticator for "exported" configurations. Typically these URLs
// are embedded as QR codes, encoding a proprietary URL in this format:
//
//	otpauth-migration://offline?data=<content>
//
// The content is a protocol buffer message encoded as base64 in standard
// encoding.  Note that a single migration URL may encode multiple OTP
// settings; on success this function returns all the otpauth URLs encoded by
// the content.  It will always return at least one URL, or report an error.
func ParseMigrationURL(s string) ([]*URL, error) {
	rest, ok := strings.CutPrefix(s, "otpauth-migration://")
	if !ok {
		return nil, errors.New("missing otpauth-migration schema prefix")
	}
	content, ok := strings.CutPrefix(rest, "offline?data=")
	if !ok {
		return nil, errors.New("unrecognized path format")
	}
	dec, err := url.QueryUnescape(content)
	if err != nil {
		return nil, fmt.Errorf("invalid data: %w", err)
	}
	bits, err := base64.StdEncoding.DecodeString(dec)
	if err != nil {
		return nil, fmt.Errorf("invalid base64: %w", err)
	}
	return parseMigrations(bits)
}

// MigrationURL encodes the specified [URL] values into an equivalent
// otpauth-migration URL in the format generated by the Google Authenticator
// for "exported" configurations.
//
// An error is reported if any of the given URLs could not be converted.  Not
// all possible configurations can be represented in the authenticator export
// format, notably only certain hash algorithms and digit counts are allowed.
//
// Note: The string generated by this function is equivalent in effect but may
// not be bytewise identical to the string generated by an authenticator
// application for the same URLs, as the results are protobuf encoded and may
// vary by order of fields and inclusion or omission of defaults.
func MigrationURL(urls []*URL) (string, error) {
	data, err := encodeMigrations(urls)
	if err != nil {
		return "", err
	}
	enc := url.QueryEscape(base64.StdEncoding.EncodeToString(data))
	return `otpauth-migration://offline?data=` + enc, nil
}

/*
The content of a migration URL is a wire-format protocol buffer message.

I don't want to take a dependency on protobuf, since that pulls in a lot of
other expensive Google nonsense, but fortunately the message structure is
fairly simple:

   message Content {
      repeated Params params = 1;

      // ... other fields not of interest.
      // If you're exporting more data than can fit in one QR code, the app may
      // split up the export into multiple codes. There are some fields here to
      // keep track of that, but they aren't relevant here.
   }

   message Params {
      bytes  secret    = 1;
      string account   = 2;
      string issuer    = 3;
      int32  algorithm = 4;  // 0: unspec, 1: SHA1, 2: SHA256, 3: SHA512, 4: MD5
      int32  digits    = 5;  // 0: unspec, 1: 6 digits, 2: 8 digits (typical Google)
      int32  type      = 6;  // 0: unspec, 1: HOTP, 2: TOTP
      uint64 counter   = 7;
   }

So here we just unpack the wire format directly.

See: https://github.com/google/google-authenticator-android/issues/118
*/

const (
	// Field ID mappings for the Params fields.
	secretField = 1 + iota
	accountField
	issuerField
	algorithmField
	digitsField
	typeField
	counterField

	// Field ID for the Params message inside Content.
	paramsField = 1
)

func encodeMigrations(urls []*URL) ([]byte, error) {
	var b wirepb.Builder
	var err error
	for _, u := range urls {
		if err != nil {
			return nil, err
		}
		b.Message(paramsField, func(ub *wirepb.Builder) {
			switch strings.ToLower(u.Type) {
			case "hotp":
				ub.Uint32(typeField, 1)
			case "totp":
				ub.Uint32(typeField, 2)
			default:
				err = fmt.Errorf("unknown type %q", u.Type)
				return
			}

			switch strings.ToUpper(u.Algorithm) {
			case "":
				// default, omit
			case "SHA1":
				ub.Uint32(algorithmField, 1)
			case "SHA256":
				ub.Uint32(algorithmField, 2)
			case "SHA512":
				ub.Uint32(algorithmField, 3)
			case "MD5":
				ub.Uint32(algorithmField, 4)
			default:
				err = fmt.Errorf("unsupported algorithm %q", u.Algorithm)
				return
			}

			switch u.Digits {
			case 0:
				// default, omit
			case 6:
				ub.Uint32(digitsField, 1) // le sigh
			case 8:
				ub.Uint32(digitsField, 2) // le sigh
			default:
				err = fmt.Errorf("unsupported digit count %d", u.Digits)
				return
			}

			if u.RawSecret != "" {
				sec, serr := u.Secret()
				if serr != nil {
					err = serr
					return
				}
				ub.String(secretField, string(sec))
			}
			if u.Issuer != "" {
				ub.String(issuerField, u.Issuer)
			}
			if u.Account != "" {
				ub.String(accountField, u.Account)
			}
			if u.Counter != 0 {
				ub.Uint64(counterField, u.Counter)
			}
		})
	}
	return b.Bytes(), err
}

// parseMigrations parses data as a wire-format protobuf message in the Content
// format described above, and returns a single URL for each instance of the
// Params found therein. Other fields of the message are ignored.
func parseMigrations(data []byte) ([]*URL, error) {
	var out []*URL
	s := wirepb.NewScanner(bytes.NewReader(data))
	for s.Next() {
		if s.ID() == paramsField {
			u, err := parseParams(s.Data())
			if err != nil {
				return nil, err
			}
			out = append(out, u)
		}
	}
	if s.Err() != nil {
		return nil, s.Err()
	} else if len(out) == 0 {
		return nil, errors.New("no URLs found")
	}
	return out, nil
}

func parseParams(data []byte) (*URL, error) {
	var out = URL{Algorithm: defaultAlgorithm, Digits: defaultDigits, Period: defaultPeriod}
	s := wirepb.NewScanner(bytes.NewReader(data))
	for s.Next() {
		switch s.ID() {
		case secretField:
			out.SetSecret(s.Data())
		case accountField:
			out.Account = string(s.Data())
		case issuerField:
			out.Issuer = string(s.Data())
		case algorithmField:
			switch v, _ := binary.Uvarint(s.Data()); v {
			case 1:
				out.Algorithm = "SHA1"
			case 2:
				out.Algorithm = "SHA256"
			case 3:
				out.Algorithm = "SHA512"
			case 4:
				out.Algorithm = "MD5"
			default:
				return nil, fmt.Errorf("unknown algorithm code %d", v)
			}
		case digitsField:
			switch v, _ := binary.Uvarint(s.Data()); v {
			case 1:
				out.Digits = 6
			case 2:
				out.Digits = 8
			default:
				return nil, fmt.Errorf("unknown digits code %d", v)
			}
		case typeField:
			switch v, _ := binary.Uvarint(s.Data()); v {
			case 1:
				out.Type = "hotp"
			case 2:
				out.Type = "totp"
			default:
				return nil, fmt.Errorf("unknown type code %d", v)
			}
		case counterField:
			v, n := binary.Uvarint(s.Data())
			if n <= 0 {
				return nil, errors.New("invalid counter value")
			}
			out.Counter = v
		}
	}
	if s.Err() != nil {
		return nil, s.Err()
	}
	return &out, nil
}
